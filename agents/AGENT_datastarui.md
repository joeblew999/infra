# CLAUDE_datastar.md

For: https://github.com/CoreyCole/datastarui

REF: https://raw.githubusercontent.com/CoreyCole/datastarui/refs/heads/main/CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with 
 in this repository.

## Project Overview

DatastarUI is a Go/templ port of shadcn/ui components that maintains pixel-perfect visual and behavioral parity while using server-side rendering with minimal JavaScript (only the 15KB Datastar library for reactivity).

## Common Commands

- `just docker-tail app` - Show recent app logs (shows 50 lines by default - use this to check for compilation errors)
- `just docker-tail tailwind` - Show recent Tailwind logs
- `just docker-shell app` - Open shell in app container

### Playwright Browser Testing

- `just playwright-up` - Start Playwright container for browser automation
- `just playwright-test` - Run all browser tests
- `just playwright-shell` - Open shell in Playwright container for interactive testing
- `just playwright-ui` - Open Playwright UI for visual test debugging

### Important Notes

- **DO NOT** run `go run main.go` or `go build` directly - use `just` commands
- **DO NOT** try to run the compiled binary - the developer has live reload running
- **DO NOT** use `just docker-follow` - Claude cannot use interactive/following commands
- **DO NOT** run `templ generate` directly - use Docker logs to check compilation
- Templ files are auto-generated by the Docker container with live reload
- Tailwind CSS runs in watch mode automatically during development
- **Check compilation errors**: Use `just docker-tail app` (shows 50 lines by default) to see templ compilation and Go build errors
- **Test changes**: Make a templ file change, then check `just docker-tail app` for rebuild logs

## Architecture

### Expression Builders Organization

- **utils/expressions.go** - Contains ONLY generic expression builders used across multiple components
- **components/[name]/expressions.go** - Contains component-specific expression builders
- **Naming Convention**: Use lowercase function names for component-specific expression builders to avoid polluting the public namespace
- **IMPORTANT**: Never add component-specific logic to utils/expressions.go. If an expression builder is only used by one component, it belongs in that component's folder

### Tech Stack

- **Go 1.24+** with Echo framework for HTTP server
- **templ** - Go templating engine for type-safe HTML templates
- **Datastar** - 15KB JavaScript library for reactivity via data-\* attributes
- **Tailwind CSS** - Utility-first CSS framework, exact classes from shadcn/ui
- **tailwind-merge-go** - For merging Tailwind classes safely

### Project Structure

```
datastarui/
├── components/                   # Reusable UI components
│   ├── button/
│   │   ├── button.templ          # Component template (and signal type)
│   │   ├── args.go               # Component parameter args
|   │   ├── expressions.go        # Datastar expression builders
│   │   └── variants.go           # CSS variants
├── utils/                        # Utility libraries
│   ├── signals.go                # Signal management with namespacing
│   ├── expressions.go            # Datastar expression builders
│   └── data_class.go             # Conditional CSS class helpers
├── pages/
│   ├── components/               # Component demo pages
│   └── home_page.templ           # Home page
├── layouts/                      # Page layouts and navigation
├── static/css/                   # Tailwind CSS files
├── docs/
│   └── guide.md                  # Development patterns guide
└── main.go                       # Server and routing
```

### Component Pattern

Each component follows a consistent 3-file pattern:

1. **Template** (`component.templ`) - templ markup with Datastar attributes
   - **IMPORTANT:** Always put the signal struct in the top of this file
1. **Types** (`types.go`) - Go structs defining component args
1. **Variants** (`variants.go`) - CSS class generation matching shadcn/ui exactly
1. **Expressions** (`expressions.go`) - Datastar expression builders

## Datastar Development Guidelines

### IMPORTANT: Use Utility Libraries

**Always use the utility libraries in `utils/` instead of string concatenation for Datastar expressions.**

See `/docs/guide.md` for comprehensive patterns and examples.

### Core Utilities

1. **Signal Management** (`utils/signals.go`)

```go
signals := utils.Signals(args.ID, MySignals{
    Open: false,
    Value: "default",
})
// Use: signals.DataSignals, signals.Signal("prop"), signals.Toggle("open"), etc.
```

2. **Expression Builders** (`utils/expressions.go`)

```go
expr := utils.NewExpression().
    SetSignal("modal.open", "false").
    Build()
```

3. **Conditional Signal Classes** (`utils/data_class.go`)

```go
dataClass := utils.HighlightedItem("select.highlighted", index)
// Use with: data-class={ dataClass }
```

### Signal Naming Convention

- Use lowercase with underscores in `args.ID` (e.g., `user_profile`, `item_list`)
- **Never** use uppercase, dashes, or periods in signal names
- Components should validate `args.ID` format and throw errors for invalid names

### Signal Architecture

- Signals are **globally scoped** on the page
- Use `args.ID` as namespace: `$user_profile.name`, `$item_list.selected`
- Only leaf nodes are valid signals (not intermediate namespaces)
- Initialize signals using `utils.Signals()` helper

### ⚠️ Datastar Footguns & Best Practices

#### 1. **Click-Outside Handler Issues**

**Problem**: `data-on-click__outside` fires immediately when clicking the element that opens a popover/dropdown, causing the "two-click" bug.

**Why it happens**:

- User clicks button to open popover → handler sets `open = true`
- Click event bubbles up → Datastar evaluates click-outside
- Click-outside sees `open = true` and immediately sets it back to `false`

**Solutions**:

```go
// ❌ BAD: Generic click-outside handler
clickOutsideHandler := signals.Signal("open") + " ? " + signals.Set("open", "false") + " : null"

// ✅ GOOD: Exclude the trigger button from click-outside
datepickerSelector := fmt.Sprintf("[data-datepicker-id=\"%s\"]", datePickerID)
clickOutsideHandler := signals.Signal("open") + " && !evt.target.closest('" + datepickerSelector + " button[data-on-click*=\"open\"]') ? " + signals.Set("open", "false") + " : null"

// ✅ BETTER: Use utility function
clickOutsideHandler := utils.NewConditional(
    signals.Signal("open") + " && !evt.target.closest('" + triggerSelector + "')",
    signals.Set("open", "false"),
    "null"
).Build()
```

#### 2. **Focus Capture Conflicts**

**Problem**: `data-on-focus__capture` on containers captures ALL focus events, including button clicks.

**Why it happens**:

- Container has `data-on-focus__capture="$signal.open = true"`
- Click calendar button → button receives focus → capture fires
- Creates conflicts with button's own click handler

**Solutions**:

```go
// ❌ BAD: Captures all focus events
data-on-focus__capture={ signals.Set("open", "true") }

// ✅ GOOD: Only capture input focus
focusCapture := utils.NewFocusCapture().
    OnlyInputs().
    SetSignal(signals, "open", "true").
    Build()
// Result: evt.target.tagName.toLowerCase() === 'input' ? $signal.open = true : null
```

#### 3. **Event Propagation Issues**

**Problem**: Using `evt.stopPropagation()` breaks event coordination between components.

**Why it happens**:

- Component A uses stopPropagation to prevent unwanted behavior
- Component B's click-outside handler never fires because event doesn't bubble
- Multiple popovers/dropdowns stay open simultaneously

**Solutions**:

```go
// ❌ BAD: Stops all event propagation
return signals.Toggle("open") + "; evt.stopPropagation()"

// ✅ GOOD: Use targeted click-outside exclusions instead
// Let events bubble naturally and handle them specifically
```

#### 4. **Complex Expression Readability**

**Problem**: String concatenation creates unreadable, error-prone expressions.

**Solutions**:

```go
// ❌ BAD: String concatenation nightmare
handler := "evt.key === 'Escape' && " + check + " ? (" + 
    "evt.preventDefault(), " + signals.Set("open", "false") + 
    ", document.getElementById('" + id + "').focus()) : null"

// ✅ GOOD: Use expression builders
handler := utils.NewKeyHandler("Escape").
    WithCondition(check).
    PreventDefault().
    AddSignalSet(signals, "open", "false").
    FocusElement(id).
    Build()
```

#### 5. **Multiple Event Handlers**

**Problem**: Combining multiple event handlers with string concatenation is error-prone.

**Solutions**:

```go
// ❌ BAD: Manual concatenation
keyHandler := escapeHandler + "; " + tabHandler + "; " + enterHandler

// ✅ GOOD: Use utilities
keyHandler := utils.NewMultipleAssignments().
    Add(escapeHandler).
    Add(tabHandler).
    Add(enterHandler).
    Build()
```

#### 6. **Blur/Focus Handler Ordering**

**Problem**: Blur handlers can interfere with click handlers due to event ordering.

**Why it happens**:

1. User clicks button
1. Input loses focus → blur handler fires
1. Button click handler fires
1. Conflicting state changes

**Solutions**:

- Use debounced handlers when appropriate
- Carefully order signal updates
- Test interaction between blur and click handlers

### Best Practices Summary

1. **Always use utility functions** instead of string concatenation
1. **Test event bubbling** - use browser DevTools to trace event flow
1. **Be specific with selectors** in click-outside handlers
1. **Avoid stopPropagation** unless absolutely necessary
1. **Initialize signals properly** with explicit values
1. **Use conditional expressions** for null-safe operations
1. **Test focus/blur interactions** thoroughly
1. **Document complex event flows** in comments

### Key Patterns

- **Args down, events up** - encapsulate state, communicate via defined interfaces
- **Server-driven state** - backend is single source of truth
- **Hypermedia approach** - let server determine available actions
- **No string concatenation** - use expression builders for maintainability
- **Component-specific expressions** - Keep component-specific logic in component folders, not utils

### Common Datastar Attributes

- `data-signals` - Initialize component state (use `signals.DataSignals`)
- `data-on-click` - Handle click events
- `data-text` - Display signal values
- `data-show`/`data-hide` - Conditional visibility
- `data-class` - Conditional CSS classes (use `utils.DataClass`)
- `data-bind-*` - Two-way data binding
- `data-indicator-*` - Loading states for fetch requests

## templ Specific Guidelines

### Required Patterns

- All page content must be inside `@l.Root()` layout wrapper
- Use `templ.SafeURL()` for href attributes to prevent XSS
- Use `templ.Attributes` for flexible HTML attribute passing
- Implement conditional rendering with `switch` statements

### Component Composition

- Nest components properly for multi-part components (e.g., breadcrumbs)
- Follow existing import patterns in main.go for routing
- Create comprehensive demo pages showing all component variants

## Development Workflow

### Adding New Components

1. **Analyze** source shadcn/ui component for structure and variants
1. **Create** component directory with 3-file pattern
1. **Implement** exact CSS classes using tailwind-merge-go
1. **Add** Datastar reactivity using utility libraries:
   - Use `utils.Signals()` for signal management
   - Use `utils.NewExpression()` for complex expressions
   - Use `utils.NewDataClass()` for conditional classes
1. **Create** demo page in `pages/components/[component]/`
1. **Update** routing in main.go and sidebar.go
1. **Test** all variants and interactive behaviors with Playwright MCP

### CSS and Styling

- Use exact CSS classes from shadcn/ui for pixel-perfect parity
- Leverage Tailwind CSS design tokens (colors, spacing, typography)
- Support dark mode with CSS custom properties
- Maintain accessibility with proper ARIA attributes

## Testing Strategy

### Playwright MCP for Debugging

The Playwright MCP server provides browser automation for debugging Datastar components. Key commands:

#### IMPORTANT: Always Check Console First

- **First step after navigating**: Run `mcp__playwright__playwright_console_logs type="all" clear=true`
- **After each interaction**: Check console again for Datastar runtime errors
- **Common errors**: Undefined signals, expression syntax errors, missing signal namespaces

#### Navigation and Setup

- `mcp__playwright__playwright_navigate` - Navigate to a URL (e.g., http://localhost:4242/components/datepicker)
- `mcp__playwright__playwright_screenshot name="[component]-[state]"` - Capture visual state
- `mcp__playwright__playwright_get_visible_html` - Get DOM structure
- `mcp__playwright__playwright_click "[data-selector]"` - Click element
- `mcp__playwright__playwright_press_key "ArrowDown"` - Press key
- `mcp__playwright__playwright_hover "[element]"` - Hover over element
- More in [docs/playwright-commands.md](./docs/playwright-commands.md)

#### Console Monitoring

- `mcp__playwright__playwright_console_logs` - Enhanced console logging with error detection (requires executeautomation/mcp-playwright)
- **Supports log levels**: `error`, `warn`, `info`, `log`, `debug`, `all`
- `mcp__playwright__playwright_console_logs type="all" clear=true` - Get all console logs
- `mcp__playwright__playwright_console_logs type="error"` - Get console errors
- **Captures Datastar errors**: Successfully detects "GenerateExpression" runtime errors with full context
- **Usage**: `mcp__playwright__playwright_console_logs type="error"` for JavaScript errors
- **Error Types**: Detects JavaScript syntax errors in Datastar expressions (missing quotes, parentheses, etc.)
- **Clear logs**: Use `clear=true` parameter to clear previous console logs and get fresh error detection
- **Best practice**: Start debugging sessions with `mcp__playwright__playwright_console_logs type="all" clear=true`

#### Interaction Testing - Specific Selectors

**CRITICAL**: Always use highly specific selectors to avoid 30-second timeouts from multiple element matches.

**DatePicker Component Selectors:**

- **Calendar icon button**: `[data-datepicker-id="PICKER_ID"] button[data-on-click*="open"]`
  - Example: `[data-datepicker-id="range_date"] button[data-on-click*="open"]`
  - This targets the calendar icon that toggles the popover
- **Popover container**: `[data-datepicker-id="PICKER_ID"] [data-slot="datepicker-popover"]`
  - Example: `[data-datepicker-id="single_date"] [data-slot="datepicker-popover"]`
- **Calendar day buttons**: `[data-datepicker-id="PICKER_ID"] [data-slot="datepicker-popover"] button:has-text("DAY")`
  - Example: `[data-datepicker-id="range_date"] [data-slot="datepicker-popover"] button:has-text("15")`
  - Only click when popover is visible (check `style.display !== "none"`)

**Navigation and Calendar Testing:**

- **Month navigation**: `[data-datepicker-id="PICKER_ID"] [data-slot="datepicker-popover"] button[data-on-click*="currentDate"]`
- **Input fields**: `[data-datepicker-id="PICKER_ID"] input[type="text"]`

**Common Issues:**

- **Element Overlap**: Calendar day buttons can overlap calendar icon buttons, causing click timeouts
- **Multiple Matches**: Generic selectors like `button[type="button"]` match 38-73 elements per datepicker
- **Popover State**: Always check popover visibility before clicking calendar days
- **Solution**: Use the specific `data-datepicker-id` + element role pattern above

### Common Debugging Workflow

1. Navigate to component page: `mcp__playwright__browser_navigate`
1. Clear console and check for initial errors: `mcp__playwright__browser_console_logs type="all" clear=true`
1. Interact with component: `mcp__playwright__browser_click`, `mcp__playwright__browser_type`
1. Check console for all messages: `mcp__playwright__browser_console_logs type="all"` (includes errors, logs, and debug messages)
1. Take screenshot to verify visual state: `mcp__playwright__browser_take_screenshot`
1. Inspect DOM for signal attributes: `mcp__playwright__browser_snapshot`