//go:build ignore

package main

import (
	"encoding/json"
	"fmt"
	"os"
	"path/filepath"
	"strings"
	"text/template"
	"time"
)

// DepBinary represents a binary definition from dep.json
type DepBinary struct {
	Name        string `json:"name"`
	Description string `json:"description"`
}

// Generate binary constants from dep.json
func main() {
	// Read dep.json
	depPath := filepath.Join("..", "dep", "dep.json")
	data, err := os.ReadFile(depPath)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Failed to read dep.json: %v\n", err)
		os.Exit(1)
	}

	var binaries []DepBinary
	if err := json.Unmarshal(data, &binaries); err != nil {
		fmt.Fprintf(os.Stderr, "Failed to parse dep.json: %v\n", err)
		os.Exit(1)
	}

	// Generate constants
	tmpl := template.Must(template.New("binaries").Parse(`// Code generated by go generate; DO NOT EDIT.
// This file was generated by pkg/config/generate_binaries.go from pkg/dep/dep.json

package config

// Generated at {{ .Timestamp }}

// Binary name constants - auto-generated from dep.json
// Using constants prevents garble obfuscation and provides type safety
const (
{{- range .Binaries }}
	Binary{{ .ConstName }} = "{{ .Name }}"{{ if .Description }} // {{ .Description }}{{ end }}
{{- end }}
)

// AllBinaryNames returns all available binary names from dep.json
func AllBinaryNames() []string {
	return []string{
{{- range .Binaries }}
		Binary{{ .ConstName }},
{{- end }}
	}
}

// IsBinaryNameValid checks if a binary name is valid according to dep.json
func IsBinaryNameValid(name string) bool {
	for _, validName := range AllBinaryNames() {
		if validName == name {
			return true
		}
	}
	return false
}
`))

	// Prepare template data
	type TemplateData struct {
		Timestamp time.Time
		Binaries  []struct {
			Name        string
			ConstName   string
			Description string
		}
	}

	templateData := TemplateData{
		Timestamp: time.Now(),
		Binaries:  make([]struct {
			Name        string
			ConstName   string
			Description string
		}, len(binaries)),
	}

	for i, binary := range binaries {
		templateData.Binaries[i] = struct {
			Name        string
			ConstName   string
			Description string
		}{
			Name:        binary.Name,
			ConstName:   toPascalCase(binary.Name),
			Description: binary.Description,
		}
	}

	// Generate the file
	outputFile := "binaries_gen.go"
	f, err := os.Create(outputFile)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Failed to create %s: %v\n", outputFile, err)
		os.Exit(1)
	}
	defer f.Close()

	if err := tmpl.Execute(f, templateData); err != nil {
		fmt.Fprintf(os.Stderr, "Failed to execute template: %v\n", err)
		os.Exit(1)
	}

	fmt.Printf("Generated %s with %d binary constants\n", outputFile, len(binaries))
}

// toPascalCase converts kebab-case to PascalCase for Go constants
func toPascalCase(s string) string {
	parts := strings.Split(s, "-")
	var result strings.Builder
	
	for _, part := range parts {
		if len(part) > 0 {
			result.WriteString(strings.ToUpper(string(part[0])))
			if len(part) > 1 {
				result.WriteString(part[1:])
			}
		}
	}
	
	return result.String()
}